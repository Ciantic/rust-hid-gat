use bt_only_headers::messages::HciAcl;
use bt_only_headers::messages::LeConnectionComplete;
use bt_only_headers::messages::SmpPairingReqRes;
use bt_only_headers::messages::*;
use bt_only_headers::packer::*;

#[test]
fn deserialize_write_name() {
    let mut packet = Packet::from_slice(&[
        0x13, 0xc, 0xf8, 0x4d, 0x79, 0x20, 0x50, 0x69, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    ]);
    let msg = packet.unpack::<HciCommand>().unwrap();
    if let HciCommand::WriteLocalName(name) = msg {
        assert_eq!(name.get(), "My Pi");
    } else {
        panic!("Expected WriteLocalName");
    }
}

#[test]
fn serialize_write_name() {
    let mut packet = Packet::new();
    packet
        .pack(&HciCommand::WriteLocalName(FixedSizeUtf8::<248>::new(
            "My Pi",
        )))
        .unwrap();
    assert_eq!(
        &[
            0x13, 0xc, 0xf8, 0x4d, 0x79, 0x20, 0x50, 0x69, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        ],
        packet.get_bytes()
    );
}

#[test]
fn deserialize_connection_handle() {
    let mut packet = Packet::from_slice(&[0xEF, 0xBE]);
    let handle = ConnectionHandle::from_packet(&mut packet).unwrap();
    assert_eq!(handle, ConnectionHandle(0xBEEF));
}

#[test]
fn deserialize_role() {
    let mut packet = Packet::from_slice(&[0x00]);
    let handle = Role::from_packet(&mut packet).unwrap();
    assert_eq!(handle, Role::Central);
}

#[test]
fn test_hci_command_reset() {
    let mut packet = Packet::from_slice(&[0x03, 0x0C, 0x00]);
    let handle = HciCommand::from_packet(&mut packet).unwrap();
    assert_eq!(handle, HciCommand::Reset);

    let mut packet = Packet::new();
    packet.pack(&HciCommand::Reset).unwrap();
    assert_eq!(packet.get_bytes(), &[0x03, 0x0C, 0x00]);
}

#[test]
fn test_hci_command_set_event_mask() {
    let mut packet =
        Packet::from_slice(&[0x1, 0xc, 0x8, 0xff, 0xff, 0xfb, 0xff, 0x7, 0xf8, 0xbf, 0x3d]);
    let handle = HciCommand::from_packet(&mut packet).unwrap();
    assert_eq!(handle, HciCommand::SetEventMask(4449547670108504063));

    let mut packet = Packet::new();
    packet
        .pack(&HciCommand::SetEventMask(4449547670108504063))
        .unwrap();
    assert_eq!(
        packet.get_bytes(),
        &[
            0x01, 0x0c, 0x08, 0xff, 0xff, 0xfb, 0xff, 0x7, 0xf8, 0xbf, 0x3d
        ]
    );
}

#[test]
fn hci_status() {
    let mut packet = Packet::from_slice(&[0x00]);
    let handle = HciStatus::from_packet(&mut packet).unwrap();
    assert_eq!(handle, HciStatus::Success);

    let mut packet = Packet::from_slice(&[0x05]);
    let handle = HciStatus::from_packet(&mut packet).unwrap();
    assert_eq!(handle, HciStatus::Failure(0x05));
}
#[test]
fn serialize_hci_status() {
    let mut packet = Packet::from_slice(&[0x05]);

    HciStatus::Success.to_packet(&mut packet).unwrap();
    assert_eq!(packet.get_bytes(), &[0x00]);

    HciStatus::Failure(0x05).to_packet(&mut packet).unwrap();
    assert_eq!(packet.get_bytes(), &[0x00, 0x05]);
}

#[test]
fn test_event() {
    const DATA: [u8; 21] = [
        0x3e, 0x13, 0x1, 0x0, 0x40, 0x0, 0x1, 0x0, 0x26, 0xe, 0xd6, 0xe8, 0xc2, 0x50, 0x30, 0x0,
        0x0, 0x0, 0xc0, 0x3, 0x1,
    ];
    let mut packet = Packet::from_slice(&DATA);
    let msg = HciEvent::from_packet(&mut packet).unwrap();

    let expected = HciEvent::LeMeta(EvtLeMeta::LeConnectionComplete(LeConnectionComplete {
        status: HciStatus::Success,
        connection_handle: ConnectionHandle(0x0040),
        role: Role::Peripheral,
        peer_address_type: AddressType::Public,
        peer_address: BdAddr([0x26, 0xe, 0xd6, 0xe8, 0xc2, 0x50]),
        connection_interval: 48,
        peripheral_latency: 0,
        supervision_timeout: 960,
        central_clock_accuracy: ClockAccuracy::Ppm250,
    }));
    assert_eq!(msg, expected);

    // Ensure it can be serialized back to the original bytes
    let mut new_packet = Packet::new();
    new_packet.pack(&expected).unwrap();
    assert_eq!(new_packet.get_bytes(), DATA.to_vec());
}

#[test]
fn test_auth_req() {
    let m = AuthenticationRequirements {
        bonding: true,
        mitm_protection: true,
        secure_connections: true,
        keypress_notification: false,
        ct2: true,
        _reserved: 0,
    };

    let mut packet = Packet::new();
    packet.pack(&m).unwrap();
    assert_eq!(packet.get_bytes(), vec![0x2d]);

    let mut packet = Packet::from_slice(&[0x2d]);
    let res_msg = packet.unpack::<AuthenticationRequirements>();
    assert_eq!(res_msg, Ok(m));
}

#[test]
fn test_keydistribution_flags() {
    let v = KeyDistributionFlags {
        enc_key: true,
        id_key: false,
        sign_key: true,
        link_key: false,
        _reserved: 0,
    };

    let mut packet = Packet::new();
    packet.pack(&v).unwrap();
    assert_eq!(packet.get_bytes(), vec![0b0000_0101]);
}

#[test]
fn test_pairing_request() {
    // 02 40 20 0b 00 07 00 06 00 01 04 00 2d 10 0e 0f
    const DATA: [u8; 16] = [
        0x02, 0x40, 0x20, 0x0b, 0x00, 0x07, 0x00, 0x06, 0x00, 0x01, 0x04, 0x00, 0x2d, 0x10, 0x0e,
        0x0f,
    ];
    let mut packet = Packet::from_slice(&DATA);
    let res_msg = packet.unpack::<H4Packet>();
    let msg = H4Packet::Acl(HciAcl {
        connection_handle: ConnectionHandle(64),
        pb: PacketBoundaryFlag::FirstFlushable,
        bc: BroadcastFlag::PointToPoint,
        msg: L2CapMessage::Smp(SmpPdu::PairingRequest(SmpPairingReqRes {
            io_capability: IOCapability::KeyboardDisplay,
            oob_data_flag: OOBDataFlag::OobNotAvailable,
            authentication_requirements: AuthenticationRequirements {
                bonding: true,
                mitm_protection: true,
                secure_connections: true,
                keypress_notification: false,
                ct2: true,
                _reserved: 0,
            },
            max_encryption_key_size: 16,
            initiator_key_distribution: KeyDistributionFlags {
                enc_key: false,
                id_key: true,
                sign_key: true,
                link_key: true,
                _reserved: 0,
            },
            responder_key_distribution: KeyDistributionFlags {
                enc_key: true,
                id_key: true,
                sign_key: true,
                link_key: true,
                _reserved: 0,
            },
        })),
    });
    assert_eq!(res_msg.as_ref(), Ok(&msg));

    // Serializes back to the original bytes
    let mut packer2 = Packet::new();
    packer2.pack(&msg).unwrap();
    let serialized_bytes = packer2.get_bytes();
    assert_eq!(DATA.to_vec(), serialized_bytes);
}

#[test]
fn test_pairing_request_2() {
    const DATA: [u8; 15] = [
        0x40, 0x20, 0x0b, 0x00, 0x07, 0x00, 0x06, 0x00, 0x01, 0x04, 0x00, 0x2d, 0x10, 0x0e, 0x0f,
    ];
    let mut packet = Packet::from_slice(&DATA);
    let h: ConnectionHandle = packet.set_bits(12).unpack().unwrap();
    println!("{:x?}", h.0);

    let v = packet.set_bits(2).next_if_eq(&[0b10]);
    println!("{:?}", v);

    // let p: u8 = packet.set_bits(2).unpack().unwrap();
    // Print binary
    // println!("{:?}", p);
    // println!("{:08b}", p);
    // packet.unpack()
}

#[test]
fn test_complete_data() {
    let input: &[u8; 71] = &[
        0x4, 0xe, 0x44, 0x1, 0x2, 0x10, 0x0, 0xff, 0xff, 0xff, 0x3, 0xcc, 0xff, 0xef, 0xff, 0xff,
        0xff, 0xec, 0x1f, 0xf2, 0xf, 0xe8, 0xfe, 0x3f, 0xf7, 0x8f, 0xff, 0x1c, 0x0, 0x4, 0x0, 0x61,
        0xf7, 0xff, 0xff, 0x7f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x7, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0,
    ];

    let mut packet = Packet::from_slice(input);
    let msg = H4Packet::from_packet(&mut packet).unwrap();
    println!("{:?}", msg);
}

/*
#[test]
fn test_role() {
    assert_eq!(Role::Central.to_bytes().unwrap(), vec![0x00]);
    assert_eq!(Role::Peripheral.to_bytes().unwrap(), vec![0x01]);

    let ((rest, offset), v) = Role::from_bytes((&[0x00, 0xFF], 0)).unwrap();
    assert_eq!(v, Role::Central);
    assert_eq!(offset, 0);
    assert_eq!(rest.len(), 1);
    assert_eq!(rest[0], 0xFF);

    let ((rest, offset), v) = Role::from_bytes((&[0x01, 0xFF], 0)).unwrap();
    assert_eq!(v, Role::Peripheral);
    assert_eq!(offset, 0);
    assert_eq!(rest.len(), 1);
    assert_eq!(rest[0], 0xFF);

    // Error
    let err = Role::from_bytes((&[0x02, 0xFF], 0)).unwrap_err();
    assert_eq!(
        err.to_string(),
        "Parse error: Could not match enum variant id = 2 on enum `Role`"
    );
}

#[test]
fn test_address_type() {
    assert_eq!(AddressType::Public.to_bytes().unwrap(), vec![0x00]);
    assert_eq!(AddressType::Random.to_bytes().unwrap(), vec![0x01]);

    let ((rest, offset), v) = AddressType::from_bytes((&[0x00, 0xFF], 0)).unwrap();
    assert_eq!(v, AddressType::Public);
    assert_eq!(offset, 0);
    assert_eq!(rest.len(), 1);
    assert_eq!(rest[0], 0xFF);

    let ((rest, offset), v) = AddressType::from_bytes((&[0x01, 0xFF], 0)).unwrap();
    assert_eq!(v, AddressType::Random);
    assert_eq!(offset, 0);
    assert_eq!(rest.len(), 1);
    assert_eq!(rest[0], 0xFF);
}

#[test]
fn test_hci_status() {
    assert_eq!(HciStatus::Success.to_bytes().unwrap(), vec![0x00]);
    assert_eq!(HciStatus::Failure(0x05).to_bytes().unwrap(), vec![0x05]);

    let ((rest, offset), v) = HciStatus::from_bytes((&[0x00, 0xFF], 0)).unwrap();
    assert_eq!(v, HciStatus::Success);
    assert_eq!(offset, 0);
    assert_eq!(rest.len(), 1);
    assert_eq!(rest[0], 0xFF);

    let ((rest, offset), v) = HciStatus::from_bytes((&[0x05, 0xFF], 0)).unwrap();
    assert_eq!(v, HciStatus::Failure(0x05));
    assert_eq!(offset, 0);
    assert_eq!(rest.len(), 1);
    assert_eq!(rest[0], 0xFF);
}

#[test]
fn test_connection_handle() {
    assert_eq!(
        ConnectionHandle(0xBEEF).to_bytes().unwrap(),
        vec![0xEF, 0xBE]
    );

    let ((rest, offset), v) = ConnectionHandle::from_bytes((&[0xEF, 0xBE, 0xCA], 0)).unwrap();
    assert_eq!(v, ConnectionHandle(0xBEEF));
    assert_eq!(offset, 0);
    assert_eq!(rest.len(), 1);
    assert_eq!(rest[0], 0xCA);
}
*/
